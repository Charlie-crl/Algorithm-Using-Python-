# 算法杂谈

###时间复杂度：

> 1.加法比乘法时间复杂度更优

> 2.解递推方程式方法：

######公式法：

Tn = aT(n/b) + f(n)

比较n^logba 与 f(n)

1.前者比较大，解为T(n) = O(n^logba)

2.后者比较大，解为T(n) = O(f(n))

3.一样大，解为T(n) = O(n^logba * lgn)

如 Tn = 9T(n / 3 ) + n

T(n) = n^log39 = n^2 >n

则T(n) = O(n^2)

######展开式

如上，若T(n) = 2T(n-1) + n

则不适用于公式法，用展开式也就是用T(n-2)代替T(n-1)依次迭代，形成一个递归树，可计算

######代入式（猜测法）

如：求解递推方程

T(n)=T(n/2)+T(n/4)+cn, c是常数，T(1)=1

解：假定有任意的m<n,T(m)<=cm,代入递推式可得：

T(n) <= n/2 + n/4 + cn

=n(3/4 + c)

即证T(n) = O(n)

> 3.平均时间复杂度：

> 如线性搜索：相当于平均搜索次数
>
> 1/n * 1 + 1/n * 2 + 1/n * 3 + ... +1/n * n = O(n)
>
> 1/n指每个被移动的概率，数字1,2,3指这个空的搜索次数

### 分治：

该问题所分解的子问题的解可以合并为该问题的解，不然选择贪心或动态规划。

该问题所分解的各个子问题是相互独立的，即子问题之间不包括公共的子问题，这涉及到分治法的效率，若各子问题不是独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。

在用分治法设计算法时，最好使子问题的规模大致相同。即将一个问题分成大小相等的K个子问题的处理方法是行之有效的。这种使子问题规模大致相等的做法是出自一种平衡子问题的思想，它几乎总是比子问题规模不等的做法要好

